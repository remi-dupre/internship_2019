\documentclass[12px]{article}

\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{amsthm}
\usepackage{babel}
\usepackage{enumitem}
\usepackage[T1]{fontenc}
\usepackage[a4paper]{geometry}
\usepackage{hyperref}
\usepackage[utf8]{inputenc}
\usepackage{mathtools}
\usepackage{pdfpages}
\usepackage{stmaryrd}
\usepackage[textsize=small]{todonotes}
\usepackage{xcolor}

% Packages parameters
\setlist{noitemsep}

% Theorems setup
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{problem}{Problem}
\newtheorem{theorem}{Theorem}

% Automaton setup
\usetikzlibrary{arrows.meta, automata, bending, positioning, shapes.misc}
\tikzstyle{automaton}=[shorten >=1pt, >={Stealth[bend,round]}, initial text=]

% Function symbols
\DeclareMathOperator{\Ref}{Ref}
\newcommand{\Span}[1]{\left[ #1 \right\rangle}

\title{%
  Internship Report --- M2 MPRI \\
  Constant delay enumeration for documents spanners
}
\author{Rémi Dupré}


\begin{document}
  \maketitle

  \input{summary.tex}
  \pagebreak

  \section{Introduction}

    The problem of finding a substring from a text belonging to a given
    regular language has been widely studied. In particular Thompson
    introduced an automata based approach in
    1968~\cite{thompson1968programming} which is now known as one of the
    fastest implementation for regular expressions~\cite{cox2007regular}.

    However, as classical approaches simulate runs over a regular automaton
    while reading the input document linearly, they cannot output two
    substrings that overlap each over. Take the examples of the regexp
    \texttt{\textcolor{blue}{AUG}\textcolor{gray}{(...)\{0,2\}}\textcolor{red}{UAA}},
    matching any substring in the form $uvw \in \Sigma^*$ where $u =
    \texttt{\textcolor{blue}{AUG}}$, $|v| \in \{0, 3, 6\}$ and $w =
    \texttt{\textcolor{red}{UAA}}$. It has 3 matches over the document $d =
    \texttt{AUGAUGTGTUAAUAA}$:
      \begin{itemize}
        \item $d_0 \ldots d_8 =
          \texttt{\textcolor{blue}{AUG}\textcolor{gray}{AUGTGT}\textcolor{red}{UAA}}$
        \item $d_3 \ldots d_8 =
          \texttt{\textcolor{blue}{AUG}\textcolor{gray}{TGT}\textcolor{red}{UAA}}$
        \item $d_3 \ldots d_{11} =
          \texttt{\textcolor{blue}{AUG}\textcolor{gray}{TGTUAA}\textcolor{red}{UAA}}$
      \end{itemize}

    By allowing overlapping matches, it also mean that the output can could be
    of a quadratic size in the size of the input document. Thus, a classical
    worst case complexity analysis cannot hope to be faster than $O(|d|^2)$.
    This worst case behaviour is fairly easy to reach using the regex
    \texttt{.*} over any document $d$.

    Since the input of a pattern matching problem is typically big, this
    quadratic factor is usually too expensive. Moreover, in many real world
    cases, the output will actually be very small compared to the input.

    Thus it will be more relevant to use a different complexity measure for
    this problem, which is expressive about the size of the output. Here, we
    will use the complexity of enumeration, which integrates two measures:

    \begin{itemize}
      \item an upper bound on the time spent in the \textit{preprocessing}
        phase of the algorithm, this is the time spent computing before the
        first result is outputted.
      \item an upper bound on the \textit{delay} of the algorithm, this is
        the maximum time elapsed between the output of two results of the
        algorithm.
    \end{itemize}

    Amarilli~\&~al.~\cite{ICDT19} introduced an enumeration algorithm with a
    preprocessing phase linear in the size of the input document, and a delay
    independent of this size. My work was to adapt this algorithm for
    implementation and compare it to other existing tools.


  \section{Definitions}

    \subsection{Regular expressions and regular languages}

      \subsubsection{Finite Automata}

      \begin{definition}
        A finite automaton $\mathcal{A}$ over a finite alphabet $\Sigma$ is a
        tuple $(Q, I, \Delta, F)$ where:
          \begin{itemize}
            \item $Q$ is the set of states
            \item $I \subseteq Q$ is the finite set of initial states
            \item $F \subseteq Q$ is the set of final states
            \item $\Delta \subseteq Q \times \Sigma \times Q$ is the transition
              function
          \end{itemize}

          A \textit{run} $\rho$ over an input word $w= w_1 w_2 \ldots w_n \in
          \Sigma^*$ is a sequence of transitions $(q_0, w_1, q_1)$, $(q_1, w_2,
          q_2), \ldots, (q_{n-1}, w_n, q_n) \in \Delta^*$ where $q_0 \in I$. It
          is \textit{accepting} if $q_n \in F$.

          If an accepting run exists over an input word $w$, then $w$ is
          \textit{accepted}. The language $L(\mathcal{A})$ recognized by the
          automaton is the set of accepted words. Languages recognized by an
          automaton are called \textit{regular}.

          An automaton is called \textit{deterministic} if $|I| = 1$ and for any
          pair of state $q \in Q$ and letter $a \in \Sigma$ there is at most one
          transition $(q, a, q')$ in $\Delta$.
        \end{definition}

        Figure~\ref{fig:automata_simple} shows a standard visual representation
        for the example of an automaton $\mathcal{A} = (\{q_0, q_1, q_2, q_3\},
        \{q_0\}, \{(q_0, a, q_0), a \in \Sigma\} \cup \cdots \cup \{(q_1,
        \texttt{@}, q_2)\},\{q_3\})$.

      \subsubsection{Regular expressions}%
        \label{sec:def:regex}

        \begin{definition}
          The language of \textit{regular expressions} over an alphabet
          $\Sigma$ can recursively be defined as the language containing:
            \begin{itemize}
              \item ``$\emptyset$'' denoting the empty set of words of
                $\Sigma^*$
              \item ``$\epsilon$'' denoting the set containing only the empty
                string
              \item $\forall a \in \Sigma$, ``$a$'' denoting the set containing
                only the character a
              \item for any regular expressions $E_1$ and $E_2$, ``$(E_1)
                (E_2)$'' denoting the set of concatenations of a word of $E_1$
                with a word of $E_2$
              \item for any regular expressions $E_1$ and $E_2$,
                ``$(E_1)|(E_2)$'' denoting the union of words of $E_1$ and
                $E_2$
              \item for any regular expression $E$, ``${(E)}^*$'' denoting the
                set containing $\epsilon$ and any other concatenation of words
                of $E$
            \end{itemize}

          The languages denoted by regular expressions are regular languages,
          (the languages recognised by finite automata).
        \end{definition}

        \paragraph{Extra notations}
          Some extra syntax can be introduced to make the
          regular expressions more pleasant to use, some of it will be used to
          make examples more readable in this report:
            \begin{itemize}
              \item ``.'' denotes the entire alphabet $\Sigma$
              \item for any regular expression $E$ and $0 \leq n \leq m$,
                ``$(E)\{n,m\}$'' denotes the languages of words containing
                concatenation of between $n$ and $m$ words of $E$
                ``$(E)\{n\}$'' denotes the set of words that are concatenation
                of exactly $n$ words of $E$
              \item for any $w \in \Sigma^*$,
                ``$[\texttt{\textasciicircum}w]$'' denotes all the words of one
                letter which is not part of $w$
              \item parenthesis can be avoided with the following conventions:
                closure has an higher precedence than concatenation which has
                higher precedence than union. For example,
                \texttt{hello|world!*} denotes the set $\{hello, world, world!,
                world!!, world!!!, \ldots\}$
            \end{itemize}

      \subsubsection{Classical algorithms}

        Given a deterministic finite automaton $\mathcal{A} = (Q, I, \Delta,
        F)$, it is possible to determine in time $O(|d|)$ whether the input
        document $d$ is part of the language recognised by $\mathcal{A}$. It
        only requires to simulate a run of the automaton while keeping in
        memory the only possible state $q_i$ reading $d_i$: initially $\{q_0\}
        = I$ and for each $1 \leq i \leq |d|$, $q_{i}$ is the only possible
        state such that $(q_{i-1}, d_i, q_i) \in \Delta$ if any, otherwise
        there is no run labeled with $d$ over $\mathcal{A}$. Finally, if the is
        such a run and it is valid ($q_n \in F$), $d \in L(\mathcal{A})$.

        If $\mathcal{A}$ is not deterministic, it is still possible to perform
        the same operation in time $O(|\mathcal{A}| |d|)$: it requires to
        simulate all possible runs by keeping the set $Q_i$ of all possible
        states of the execution of $A$ while reading $d_i$. If $\mathcal{A} =
        (Q, I, \delta, F)$:
        \begin{itemize}
          \item $Q_0 = I$
          \item $\forall 1 \leq i \leq |d|, Q_i = \{(q', d_i, q'') \in \delta,
            q' \in Q_{i-1}\}$
        \end{itemize}
        Finally, there is a valid run of $\mathcal{A}$ over $d$ if $Q_{|d|}
        \bigcap F \neq \emptyset$.

        \vspace{0.5cm}

        The next main issue is then to find an automata that recognises the
        language of an input regular expression. Thompson's algorithm
        introduces operation to recursively apply the operations of union,
        concatenation and closure to the automatons representing
        subexpressions~\cite{thompson1968programming}. This process is linear
        in the size of the expression but the resulting automata contains
        $\epsilon$-transitions that can be removed in time $O(n^2)$.

        Glushkov's algorithm in the other hand can also compute the same
        automaton with no $\epsilon$-transitions, by recursively computing the
        set of the first letters, last letters and factor two of the words in
        the regular language~\cite{glushkov1961abstract}. This process takes
        time $O(n^2)$.

      \subsubsection{Example}%

        \label{sec:example_simple}

        Let us consider the example of the regular expression $E =$
        \texttt{.*[\textasciicircum\_]+@[\textasciicircum\_]+.*} over the
        alphabet $\Sigma = \{a, b, \ldots, z, @, \texttt \_, \vdash, \dashv\}$.
        The central part (\texttt{[\textasciicircum\_]+@[\textasciicircum\_]+})
        of the expression matches an email-like pattern defined as a non-empty
        sequence of non-space characters (\texttt{[\textasciicircum\_]+})
        followed by \texttt{@}, followed by another non-empty sequence of
        non-space characters. The email-like pattern can be surrounded by any
        prefix or suffix.

        Figure~\ref{fig:automata_simple} is the graphical representation of a 4
        states automaton that recognises the same language as the above
        expression.

        For example, the word \texttt{send\_hello@world} is part of the
        language and an accepting run of the automaton of
        figure~\ref{fig:automata_simple} is $q_0 \underbrace{q_0 q_0 q_0
        q_0}_\texttt{send} q_0 \underbrace{q_1q_1q_1q_1}_\texttt{hello} q_2
        \underbrace{q_2 q_2 q_2 q_2 q_3}_\texttt{world}$.

        \begin{figure}[ht]%
          \label{fig:automata_simple}
          \centering
          \begin{tikzpicture}[automaton, auto]
            \node[state,initial]   (1)              {$q_0$};
            \node[state]           (3) [right=of 1] {$q_1$};
            \node[state]           (4) [right=of 3] {$q_2$};
            \node[state,accepting] (6) [right=of 4] {$q_3$};

            \path[->]
              (1) edge node {$\Sigma \setminus \texttt \_$} (3)
                  edge [loop above] node {$\Sigma$} ()
              (3) edge node {$@$} (4)
                  edge [loop above] node {$\Sigma \setminus \texttt \_$} ()
              (4) edge node {$\Sigma \setminus \texttt \_$} (6)
                  edge [loop above] node {$\Sigma \setminus \texttt \_$} ()
              (6) edge [loop above] node {$\Sigma$} ();
          \end{tikzpicture}
          \caption{An automata recognising the same regular language as
          \texttt{.*[\textasciicircum\_]+@[\textasciicircum\_]+.*}}
        \end{figure}

    \subsection{Document spanners and regex formulas}

      \subsubsection{Document spanner}

        \begin{definition}
          Given $\Sigma$ a finite alphabet and a \textit{document}$ d \in
          \Sigma^*$, a \textit{span} of $d$ is a pair $\Span{i, j}$ with $0
          \leq i \leq j \leq |d|$ which represents a substring of $d$ starting
          at position $i$ and ending at position $j - 1$.
        \end{definition}

        Given a finite set $\mathcal{V}$ of variables, a \textit{result} is
        defined as a mapping from these variables to spans of the input
        document.  Note that some variable may remain unassigned: formally, a
        mapping of $\mathcal{V}$ on $d$ is a function $\mu$ from some domain
        $\mathcal{V}_0 \subset \mathcal{V}$ to spans of $d$.

        We define a \textit{document spanner} to be a function assigning to
        every input document d a set of mappings, which denotes the set of
        results of the extraction task on the document d.

      \subsubsection{Ref-word}

        \begin{definition}
          Given a variable $x$, we define two distinct \textit{variable
          markers}: an \textit{open marker} $x{\vdash}$ and a \textit{close
          marker} ${\dashv}x$. The set of all variable markers of a set of
          variables $\mathcal{V}$ is noted $\Gamma_\mathcal{V}$. Formally,
          $\Gamma_\mathcal{V} = \{x{\vdash}, x \in \mathcal{V}\} \uplus
          \{{\dashv}x, x \in \mathcal{V}\}$.
        \end{definition}

        Theses markers will be handful to encode the beginning of a span (by
        using $x{\dashv}$) and the end of a span (by using ${\vdash}x$) in
        several contexts.

        \begin{definition}[\cite{peterfreund} Sec. 2.1.1]
          Given a finite alphabet $\Sigma$ and a finite set of variables
          $\mathcal{V}$, a \textit{ref-word} is a word over the extended
          alphabet $\Sigma \uplus \Gamma_\mathcal{V}$.

          A ref-word $r \in {(\Sigma \uplus \Gamma_\mathcal{V})}^*$ is
          \textit{valid} if every variable of $\mathcal{V}$ is opened and then
          closed exactly once (each variable marker of $\Gamma_\mathcal{V}$
          appears exactly once in $r$).
        \end{definition}

        All the ref-words we will consider in this report will be valid.

        For any ref-word $r$ over $\Sigma$ and some set of variables
        $\mathcal{V}$, we write $r \cap \Sigma$ to denote the subsequence of r
        where we only keep the letters that are in $\Sigma$, formally: $r \cap
        \Sigma = r_{\sigma_1} r_{\sigma_2}, \ldots, r_{\sigma_m}$ for the only
        strictly increasing $\sigma$ such that $m$ is maximal and for all $i
        \in \llbracket 1, m \rrbracket$, $r_{\sigma_i} \in \Sigma$.

        \begin{definition}
          For any valid ref-word $r$ we note $\mu^r$ the mapping from
          $\mathcal{V}$ to spans of the document $d = r \cap \Sigma$ defined as
          follows. For any $x \in \mathcal{V}, \mu^r (x) = \Span{i, j}$ such
          that there is exactly $i$ letters of $\Sigma$ before $x{\vdash}$ and
          $j$ letters of $\Sigma$ after ${\dashv}x$ in $r$.
        \end{definition}

      \subsubsection{Sequential Variable Set Automata}

        Document spanners will here be represented using \textit{variable-set
        automata} (VAs). Transitions of a VA hold labels in $\Sigma \uplus
        \Gamma_\mathcal{V}$, intuitively this allows to assign a span $\Span{i,
        j}$ to a variable $x$ if $x{\vdash}$ appears before $d_i$ and
        ${\dashv}x$ appears before $d_j$ in a run over a document $d$.

        \begin{definition}
          Given a finite alphabet $\Sigma$ and a finite set of variables
          $\mathcal{V}$ a VA is defined as a tuple $A = (Q, I, \Delta, F)$
          where $\Delta \subseteq Q \times (\Sigma \uplus \Gamma_\mathcal{V})
          \times Q$.

          A \textit{run} $\rho$ of the variable automaton $A$ over a word $d
          \in \Sigma^*$ is a run of $A$ interpreted as a finite automaton over
          a ref-word $r \in {(\Sigma \uplus \Gamma_\mathcal{V})}^*$ such that
          $r \cap \Sigma = d$. $\rho$ is \textit{accepting} $d$ if it is
          accepting $r$ for $A$ interpreted as a finite automaton. It is
          \textit{valid} if it is accepting and if the ref-word $r$ is valid.
        \end{definition}

        % A run $\sigma$ of $A$ over $d$ is defined as a sequence of
        % configurations
        %   \[ (q_0, i_0) \xrightarrow{\sigma_1} (q_1, i_1)
        %   \xrightarrow{\sigma_2} \ldots \xrightarrow{\sigma_m} (q_m, i_m) \]
        % where $i_0 = 0$, $i_m = |d|$ and for every $1 \leq j \leq m$:
        %   \begin{itemize}
        %     \item either $\sigma_j$ is a letter of $\Sigma$, we have $i_j =
        %       i_{j-1} + 1$, $d_{i_{j-1}} = \sigma_j$ and $(q_{j-1}, \sigma_j,
        %       q_j)$ is a letter transition of $A$;
        %     \item or $\sigma_j$ is a variable marker, we have $i_j = i_{j-1}$,
        %       and $(q_{j-1}, \sigma_j, q_j)$ is a variable transition of $A$. In
        %       this case we say that the variable marker $\sigma_j$ is read at
        %       position $i_j$.
        %   \end{itemize}

        % every variable
        % marker is read at most once, and whenever an open marker $x{\vdash}$ is
        % read at a position $i$ then the corresponding close marker ${\dashv}x$
        % is read at a position $i'$ with $i \leq i'$.

        We will only consider automata that cannot be accepting but not valid.
        Such an automaton is called \textit{sequential}. Note that it is
        NP-complete to decide if a VA has a valid run over a
        document~\cite{freydenberger:LIPIcs:2017}. Also note that the problem
        of deciding if an automaton is sequential is in NL and that an
        automaton can be transformed into a sequential automaton with an
        exponential blowup~\cite{ICDT19}.

        From each valid run $\rho$ labeled by a ref-word $r \in {(\Sigma \uplus
        \Gamma_\mathcal{V})}^*$, a mapping from $\mathcal{V}$ to spans of $d =
        r \cap \Sigma$ is defined by $\mu^r$. The document spanner of the
        variable automaton $A$ is then the function that assigns to every
        document $d$ the set of mappings defined by the valid runs of $A$ on
        $d$. Note that the same mapping can be defined by several different
        runs.

        % \todo{This should be more visible, and not here...}
        % The task of the enumeration algorithm defined in~\cite{ICDT19} is the
        % following: given a VA $A$ and a document $d$, enumerate without
        % duplicates the mappings that are assigned to $d$ by the document
        % spanner of $A$.

      \subsubsection{Regex Formulas}

        We define \emph{regex formulas} as regular expressions as in
        Section~\ref{sec:def:regex} where we additionally allow \emph{variable
        captures}, i.e.\ assigning spans of the documents matched by parts of
        the expressions to variables.

        \begin{definition}[\cite{peterfreund} Sec. 2.2.2]
          The set of regex formulas is closed under the same rules as in
          \ref{sec:def:regex} with the addition of the following: for any regex
          formula $E$ and variable $x \in \mathcal{V}$, $x\{E\}$ is a regex
          formula.

          A regex formula $E$ defines a language over the extended alphabet
          $\Sigma \uplus \Gamma_\mathcal{V}$ like so:
            \begin{itemize}
              \item if $E = x\{E'\}$ for some regex formula $E'$, then $E$ denotes
                the set of words of the form $x{\vdash} u {\dashv}x$ where $u$ is
                in the language denoted by $E'$
              \item the rules of closure, union and concatenation apply in the same
                way as they do for regular expressions
            \end{itemize}

          We say that a regex formula $E$ is \textit{functional} if every
          ref-word denoted by $E$ is valid.

          Given a word $d \in \Sigma^*$ and a regex formula $E$, we call
          $\Ref(E, d)$ the set of ref-words $r$ in the language denoted by $E$
          such that $r \cap \Sigma = d$.
        \end{definition}

        We will only consider functional regex formulas. Note that it is
        possible to check whether a regex formula $E$ is functional in time
        $O(|E| |\mathcal{V}|)$~\cite{peterfreund}. A functional regex formula
        $E$ defines a document spanner over words of $\Sigma^*$: $\llbracket E
        \rrbracket (d) = \{\mu^r, r \in \Ref(E, d)\}$.

        Note that classical algorithms can be extended to build a sequential
        variable automaton that defines the same document spanner as a
        functional regex. Given an input regex formula $E$ over an alphabet
        $\Sigma$, this can be done by converting $E$ into a regular expression
        over $\Sigma \uplus \Gamma_\mathcal{V}$, replacing any occurrence of
        form $x\{E'\}$ with $x{\vdash} E {\dashv}x$. The automaton obtained by
        Glushkov's algorithms can be interpreted as a variable automaton
        equivalent to $E$.

      \subsubsection{Example}

        Let us modify the example of Section~\ref{sec:example_simple} to extract
        the position of an email-like pattern into a variable:
        \texttt{.*x\{[\textasciicircum\_]+@[\textasciicircum\_]+\}.*}.

        Figure~\ref{fig:automata} represents an automaton that induces the same
        document spanner as this regex.

        For example, over the word \texttt{send\_hello@world}, the substring
        \texttt{hello@world} is assigned to $x$ in a valid run over $r =$
        \texttt{send\_$x{\vdash}$hello@world${\dashv}x$} since $\mu^r(x) =
        \Span{5, 16}$. Such a valid run over $r$ is $q_0 \underbrace{q_1 q_1 q_1
        q_1 q_1}_\texttt{send\_} \underbrace{q_2}_{{\vdash}x} \underbrace{q_3 q_3
        q_3 q_3 q_4 q_5 q_5 q_5 q_5 q_5}_\texttt{hello@world}
        \underbrace{q_6}_{{\dashv}x}$.

        \begin{figure}[ht]%
          \label{fig:automata}
          \centering
          \begin{tikzpicture}[automaton, auto]
            \node[state,initial]   (0)              {$q_0$};
            \node[state]           (1) [right=of 0] {$q_1$};
            \node[state]           (2) [right=of 1] {$q_2$};
            \node[state]           (3) [right=of 2] {$q_3$};
            \node[state]           (4) [right=of 3] {$q_4$};
            \node[state]           (5) [right=of 4] {$q_5$};
            \node[state,accepting] (6) [right=of 5] {$q_6$};
            \node[state,accepting] (7) [right=of 6] {$q_7$};

            \path[->]
              (0) edge node {$\Sigma$} (1)
                  edge [bend right] node [below] {$\vdash x$} (2)
              (1) edge node {$\vdash x$} (2)
                  edge [loop above] node {$\Sigma$} ()
              (2) edge node {$\Sigma \setminus \texttt \_$} (3)
              (3) edge node {$@$} (4)
                  edge [loop above] node {$\Sigma \setminus \texttt \_$} ()
              (4) edge node {$\Sigma \setminus \texttt \_$} (5)
              (5) edge node {$\dashv x$} (6)
                  edge [loop above] node {$\Sigma \setminus \texttt \_$} ()
              (6) edge node {$\Sigma$} (7)
              (7) edge [loop above] node {$\Sigma$} ();
          \end{tikzpicture}
          \caption{%
            An automata recognising the same regular language as
            \texttt{.*x\{[\textasciicircum\_]+@[\textasciicircum\_]+\}.*}
          }%
          \label{ex:intro-1}
        \end{figure}


    \section{Related work}

      \todo[inline]{%
        Florenzano \& al \\
        Anything else?
      }


  \section{Enumeration algorithm}

    \todo[inline]{Insert a definition of enumeration complexity somehow}

    \subsection{Formalisation of the problem}

      \todo[inline]{Add  `valid'}

      We will consider the problem of the enumeration of all possible
      assignations of variables of an input VA over a document.

      \begin{problem}%
        \label{pb:strong}
        Given a variable automaton $\mathcal{A}$ over $\Sigma$ and some set of
        variables $\mathcal{V}$ and a document $d \in \Sigma^*$, compute the
        results of the document spanner defined by $A$ over $d$. This must be
        represented as a sequence of all the distinct mappings.
      \end{problem}

      Note that this is stronger than the problem of enumerating all substrings
      matching a regular expression which was mentioned in the introduction.
      This weaker problem, defined below as Problem~\ref{pb:weak} can be
      reduced to Problem~\ref{pb:strong} as follows: given a regular expression
      $E$, we can build a regex formula $E' = ({.}* x\{E\} {.}*)$. The answer
      to Problem~\ref{pb:strong} with input regex formula $E'$ and input
      document $d$ will contain assignations of $x$ to all substrings of $d$
      that are in the language denoted by $E$.

      \begin{problem}%
        \label{pb:weak}
        Given a finite automaton $\mathcal{A}$ over $\Sigma$ and document $d
        \in \Sigma^*$, compute all the spans $\Span{i, j}$ of $d$ such that
        $d_i d_{i+1} \ldots d_j \in L(\mathcal{A})$.
      \end{problem}

      Note that the size of a solution to Problem~\ref{pb:weak} is $O(|d|^2)$
      when the input regular expression is \texttt{.*}. More generally, given
      the set of variables $\mathcal{V} = \{x_1, \ldots, x_n\}$, the solution
      to Problem~\ref{pb:strong} will be of size $O(|d|^{|\mathcal{V}|})$ for
      the input regex formula \texttt{$x_1\{.*\} x_2\{.*\} \ldots x_n\{.*\}$}.
      A standard complexity measure describes the total runtime of an
      algorithm, which will involves to iterate at least once over the output.
      Note that considering such a complexity, the naive
      Algorithm~\ref{alg:naive} is optimal for a deterministic automaton as it
      solves Problem~\ref{pb:weak} in time $O(n^2)$.

      Then, the chosen approach to compare algorithms designed to solve the
      problem has been to consider the enumeration complexity of algorithm.
      Amarilli \& al.~\cite{ICDT19} proposes an algorithm for
      Problem~\ref{pb:strong} with a preprocessing time linear in the size of
      the document and a delay independent of this document.

      \begin{theorem}[\cite{ICDT19} Th. 1.1]%
        \label{th:master}
        We can enumerate the mappings of $\mathcal{A}$ on $d$ with
        preprocessing time in $O((|Q|^4 + |\mathcal{A}|) \times |d|)$ and with
        delay $O(|V| \times (|Q|^2 + |\mathcal{A}| \times |V|^2))$, i.e.,
        linear preprocessing and constant delay in the input document, and
        polynomial preprocessing and delay in the input VA.
      \end{theorem}

    \subsection{Outlines of the algorithm}

      We will introduce the outlines of how the algorithm proposed
      in~\cite{ICDT19} works, but we will not dive into technical details for
      the sake of brevity of this report.

      During this whole section we will consider the variable automaton
      $\mathcal{A} = (Q, I, \Delta, F)$ over the alphabet $\Sigma$ and the set
      of variables $\mathcal{V}$, and the document $d \in \Sigma^*$ as the
      inputs of problem~\ref{pb:strong}.

      \subsubsection{Mapping DAG}

        The problem of enumerating the mappings captured by $\mathcal{A}$ can
        be reduced to that of enumerating path labels in a special kind of
        directed acyclic graph (DAG), called a mapping DAG. This DAG is
        intuitively a variant of the product of $\mathcal{A}$ and of the
        document $d$, where we represent simultaneously the position in the
        document and the corresponding state of $\mathcal{A}$. We will no
        longer care in the mapping DAG about the labels of letter transitions,
        so we will erase these labels and call these transitions
        $\epsilon$-transitions.  We will extend their labels to indicate the
        position in the document in addition to the variable markers.

        \begin{definition}[\cite{ICDT19} Def. 3.1]
          A mapping DAG consists of a set $V$ of vertices, an initial vertex
          $v_0 \in V$, a final vertex $v_f \in V$, and a set of edges $E$ where
          each edge $(s, x, t)$ has a source vertex $s \in V$, a target vertex
          $t \in V$, and a label $x$ that may be $\epsilon$ (in which case we
          call the edge an $\epsilon$-edge) or a finite (possibly empty) set of
          pairs $(m, i)$, where $m$ is a variable marker and $i$ is a position.
          These edges are called marker edges. We require that the graph $(V,
          E)$ is acyclic.

          The mapping $\mu(\rho)$ of a path $\rho$ in the mapping DAG is the
          union of labels of the marker edges of $\rho$: we require of any
          mapping DAG that, for every path $\rho$, this union is disjoint.

          Given a set $U$ of vertices of $G$, we write $\mathcal{M}(U)$ for the
          set of mappings of paths from a vertex of $U$ to the final vertex;
          note that the same mapping may be captured by multiple different
          paths. The set of mappings captured by $G$ is then $\mathcal{M}(G) =
          \mathcal{M}({v_0})$.
        \end{definition}

        Intuitively the mapping DAG we build is a compact representation of all
        the possible runs of $\mathcal{A}$ over the document $d$, where each
        node if this DAG represents a state of a run of $\mathcal{A}$ and each
        edge represents a step of the run, leading to a new state after either
        reading a marker edge or an $\epsilon$-transition.

        Thus, this DAG can be built in time $O(TODO)$ by exploring all possible
        states of a runs of $\mathcal{A}$ by using a basic graph exploration
        (cf.  Algorithm~\ref{alg:build_dag}). Note that only the states that
        are both accessible and co-accessible are interesting to compute
        $\mu(\rho)$.

        \begin{algorithm}[H]
          \caption{Construction of a mapping DAG equivalent to $\mathcal{A}$}%
          \label{alg:build_dag}
          \begin{algorithmic}[1]
            \State{TODO}
          \end{algorithmic}
        \end{algorithm}

        \todo[inline]{Talk about the example}

        We can also note that by construction, the mapping DAG that we build is
        \textit{leveled}. This formally sums up how the nodes of the automaton
        are added by sequentially reading letter of a word or adding a marker
        edge without reading a letter.

        \begin{definition}[\cite{ICDT19} Def. 3.8]
          A mapping DAG $G$ is leveled if its vertices $v = (q, i)$ are pairs
          whose second component $i$ is a nonnegative integer called the
          \textit{level} of the vertex and written $level(v)$, and where the
          following conditions hold:
            \begin{itemize}
              \item for the initial vertex $v_0$ (which has no incoming edges),
                the level is $0$
              \item for every -edge from u to v, we have $level(v) = level(u) +
                1$
              \item for every marker edge from u to v, we have $level(v) =
                level(u)$. Furthermore, all pairs $(m, i)$ in the label of the
                edge have $i = level(v)$.
            \end{itemize}

          The depth $D$ of $G$ is the maximal level. The width $W$ of $G$ is
          the maximal number of vertices that have the same level.
        \end{definition}

      \subsubsection{Enumeration for mapping DAGs}



        \begin{algorithm}[H]
          \caption{Enumeration from a mapping DAG (\cite{ICDT19} Alg. 1)}%
          \label{alg:main_enum}
          \begin{algorithmic}[1]
            \Function{enum}{$G, \Lambda, \texttt{mapping}$}
              \State{$\Lambda' \gets \Call{Jump}{\Lambda}$}
              \If{$\Lambda'$ is the singleton $\{v_f\}$ of the final vertex}
                \State{\Return{\texttt{mapping}}}
              \Else{}
                \For{%
                  $(\texttt{locmark}, \Lambda'')$ in
                  \Call{NextLevel}{$\Lambda'$}
                }
                  \State{%
                    \Call{enum}{%
                      $G, Lambda'', \texttt{locmark} \cup \texttt{mapping}$
                    }
                  }
                \EndFor{}
              \EndIf{}
            \EndFunction{}
          \end{algorithmic}
        \end{algorithm}

        \begin{figure}
          \caption{%
            A mapping DAG that defines the same mappings as $Ref(E, d)$ with $E
            = \texttt{.*x\{[\textasciicircum\_]+@[\textasciicircum\_]+\}.*}$
            and $d = \texttt{a\_a@b\_ab\_a.b@c}$
          }
          \center\includegraphics[width=5in]{figures/example_dag}
        \end{figure}

    \subsection{Related work}


  \section{Implementation}

    % Some implementation details, out of a subsection

    \subsection{Technical details}

      \todo{%
        Parler de Glushkov et du parsing dans l'overview de l'algo, pas
        vraiment ici
      }

      A first draft of the implementation of the algorithm was implemented
      using Python 3, this programming language is known to be slow but its
      flexibility allowed to get a working implementation after about a week of
      work. The expression are parsed using a LALR parser for a custom grammar,
      and are converted to an automata using Glushkov's algorithm.

      I later built an implementation using Rust in order to be able to compare
      performances of the algorithm with existing tools without suffering of
      the overhead of Python. The regex crate of Rust allows to access the
      AST of parsed regexps, but I still needed to compile the into automaton
      using Glushkov's algorithm in order to handle variables.

      These tools work similarly to other pattern matching tools like grep and
      use the same regex syntax. Variables are defined out of named groups, and
      instead of outputting a single match with a single assignation to groups,
      it outputs the list of all possible assignations of groups of the
      expressions.

      \todo{Introduire le naïf quelque-part par ici?}.

    \subsection{Limitations}

      \todo[inline]{trucs pas time efficient (hashtables, matrices?)}

    \subsection{Cleaning unreachable states}


  \section{Performance of the algorithm}

    \subsection{Limitations of existing tools}

      Excepted for the naive algorithms and the work of Florenzano \&
      al.~\todo{reference}, it is difficult to fairly compare to already
      existing tools. Some of these tools allow to output a list of overlapping
      matches, however this will at most output one match for each starting
      position in the output document. Regex actually have a greedy semantic
      for closures in the context of these tools, it will as a default match
      the largest possible string for each closure and can be turned to a lazy
      semantic where it only matches the smallest possible string. For
      example over the text \texttt{abcde} by using gnu grep:
        \begin{itemize}
          \item the regexp \texttt{...*} will output \texttt{abcde},
            \texttt{bcde}, \texttt{cde}, \texttt{de}
          \item the regexp \texttt{...*?} (where \texttt{*?} is the lazy
            version of \texttt{*}) will output \texttt{ab}, \texttt{bc},
            \texttt{cd} and \texttt{de}
        \end{itemize}
      However, the output to the enumeration problem should contain all
      substrings of size at least 2, thus these two kinds of greedy semantics
      don't need to be treated separatly.

    \subsection{Results}


  \pagebreak
  \bibliography{bibliography}
  \bibliographystyle{ieeetr}


  \pagebreak
  \section{Appendices}

    \subsection{Naive algorithm for the weak problem}

      The algorithm bellow can be implemented in time $O(|d|^2 \times |Q|)$ for
      a NFA by using an efficient index to access $\Delta$. It can be
      implemented in time $O(|d|^2)$ for a DFA\@: since at any step of the
      algorithm $|S| = 1$, lines 5 and 7 can be implemented in constant time.

      \begin{algorithm}[H]%
        \label{alg:naive}
        \begin{algorithmic}[1]
          \State{$\texttt{output} \gets \emptyset$}
          \For{$i = 0$ to $|d|$}
            \State{$S \gets I$}
            \For{$j = i$ to $|d|$}
              \If{$S \cap F \neq \emptyset$}
                \State{%
                  $\texttt{output} \gets \texttt{output} \uplus \{\Span{i,
                  j}\}$
                }
              \EndIf{}
              \State{%
                $S \gets \{q' \in Q, \exists q \in S, (q, d_j, q') \in \Delta
                \}$
              }
            \EndFor{}
          \EndFor{}
        \end{algorithmic}
        \caption{%
          A naive quadratic algorithm for Problem~\ref{pb:weak} with inputs
          $\mathcal{A} = (Q, I, \Delta, F)$ and $d \in \Sigma^*$
        }
      \end{algorithm}



\end{document}
