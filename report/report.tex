\documentclass[12px]{article}

\usepackage{babel}
\usepackage[T1]{fontenc}
\usepackage[a4paper]{geometry}
\usepackage{hyperref}
\usepackage[utf8]{inputenc}
\usepackage{mathtools}
\usepackage{pdfpages}
\usepackage{stmaryrd}
\usepackage[textsize=small]{todonotes}
\usepackage{xcolor}

% Automaton setup
\usetikzlibrary{arrows.meta, automata, bending, positioning, shapes.misc}
\tikzstyle{automaton}=[shorten >=1pt, >={Stealth[bend,round]}, initial text=]

% Function symbols
\DeclareMathOperator{\Ref}{Ref}
\newcommand{\Span}[1]{\left[ #1 \right\rangle}

\title{%
  Internship Report --- M2 MPRI \\
  Constant delay enumeration for documents spanners
}
\author{Rémi Dupré}


\begin{document}
  \maketitle

  \input{summary.tex}
  \pagebreak


  \section{Introduction}

    The problem of finding a substring from a text belonging to a given
    regular language has been widely studied. In particular Thompson
    introduced an automata based approach in
    1968~\cite{thompson1968programming} which is now known as one of the
    fastest implementation for regular expressions~\cite{cox2007regular}.

    However, as classical approaches simulate runs over a regular automaton
    while reading the input document linearly, they cannot output two
    substrings that overlap each over. Take the examples of the regexp
    \texttt{\textcolor{blue}{AUG}\textcolor{gray}{(.\{3\})\{0,2\}}\textcolor{red}{UAA}},
    matching any substring in the form $uvw \in \Sigma^*$ where $u =
    \texttt{\textcolor{blue}{AUG}}$, $|v| \in \{0, 3, 6\}$ and $w =
    \texttt{\textcolor{red}{UAA}}$. It has 3 matches over the document $d =
    \texttt{AUGAUGTGTUAAUAA}$:
    \begin{itemize}
      \item $d_0 \ldots d_8 =
        \texttt{\textcolor{blue}{AUG}\textcolor{gray}{AUGTGT}\textcolor{red}{UAA}}$
      \item $d_3 \ldots d_8 =
        \texttt{\textcolor{blue}{AUG}\textcolor{gray}{TGT}\textcolor{red}{UAA}}$
      \item $d_3 \ldots d_{11} =
        \texttt{\textcolor{blue}{AUG}\textcolor{gray}{TGTUAA}\textcolor{red}{UAA}}$
    \end{itemize}

    By allowing overlapping matches, it also mean that the output can could be
    of a quadratic size in the size of the input document. Thus, a classical
    worst case complexity analysis cannot hope to be faster than $O(|d|^2)$.
    This worst case behaviour is fairly easy to reach using the regex
    \texttt{.*} over any document $d$.

    Since the input of a pattern matching problem is typically big, this
    quadratic factor is usually too expensive. Moreover, in many real world
    cases, the output will actually be very small compared to the input.

    Thus it will be more relevant to use a different complexity measure for
    this problem, which is expressive about the size of the output. Here, we
    will use the complexity of enumeration, which integrates two measures:

    \begin{itemize}
      \item an upper bound on the time spent in the \textit{preprocessing}
        phase of the algorithm, this is the time spent computing before the
        first result is outputted.
      \item an upper bound on the \textit{delay} of the algorithm, this is
        the maximum time elapsed between the output of two results of the
        algorithm.
    \end{itemize}

    Amarilli~\&~al.~\cite{ICDT19} introduced an enumeration algorithm with a
    preprocessing phase linear in the size of the input document, and a delay
    independent of this size. My work was to adapt this algorithm for
    implementation and compare it to other existing tools.


  \section{Definitions}

    \subsection{Regular expressions and regular languages}

      \subsubsection{Finite Automata}

        An automaton $\mathcal{A}$ over an alphabet $\Sigma$ is a tuple $(Q, I,
        \Delta, F)$ where:\todo{Link to visual example}
        \begin{itemize}
          \item $Q$ is the set of states
          \item $I \subseteq Q$ is the set of initial states
          \item $F \subseteq F$ is the set of final states
          \item $\Delta \subseteq Q \times \Sigma \times Q$ is the transition
            function
        \end{itemize}

        A \textit{run} $\rho$ over an input word $\omega \in \Sigma^*$ is a
        sequence of transitions $(q_0, a_1, q_1), (q_1, a_2, q_2), \ldots,
        (q_{n-1}, a_n, q_n) \in \Delta^*$. It is \textit{accepting} if $q_0 \in
        I$ and $q_n \in F$.

        If an accepting run exists over an input word $\omega$, then $\omega$
        is \textit{accepted}. The language $L(\mathcal{A})$ recognized by the
        automaton is the set of accepted words. Languages recognized by an
        automaton are called regular.

        An automaton is called \textit{deterministic} if $|I| = 1$ for any
        pair of state $q \in Q$ and letter $a \in \Sigma$ there is at most one
        transition $(q, a, q')$ in $\Delta$.

      \subsubsection{Regular expressions}%
        \label{sec:def:regex}

        The language of regular expressions over an alphabet $\Sigma$ can
        recursively be defined as the language containing:

        \begin{itemize}
          \item ``$\emptyset$'' denoting the empty set of words of $\Sigma^*$
          \item ``$\epsilon$'' denoting the set containing only the empty
            string
          \item $\forall a \in \Sigma$, ``$a$'' denoting the set containing
            only the character a
          \item for any regular expressions $E_1$ and $E_2$, ``$(E_1) (E_2)$''
            denoting the set of concatenations of a word of $E_1$ with a word
            of $E_2$.
          \item for any regular expressions $E_1$ and $E_2$, ``$(E_1)|(E_2)$''
            denoting the union of words of $E_1$ and $E_2$.
          \item for any regular expression $E$, ``${(E)}^*$'' denoting the set
            containing $\epsilon$ and any other concatenation of words of $E$.
        \end{itemize}


        The languages denoted by regular expressions are regular languages,
        (the languages recognised by finite automata).

        \paragraph{Notations} Some extra syntax can be introduced to make the
        regular expressions more pleasant to use, some of it will be used to
        make examples more readable in this report:
        \begin{itemize}
          \item ``.'' denotes the entire alphabet $\Sigma$
          \item for any regular expression $E$ and $0 \leq n \leq m$,
            ``$(E)\{n,m\}$'' denotes the languages of words containing
            concatenation of between $n$ and $m$ words of $E$. ``$(E)\{n\}$''
            denotes the set of words that are concatenation of exactly $n$
            words of $E$.
          \item parenthesis can be avoided with the following conventions:
            closure has an higher precedence than concatenation which has
            higher precedence than union. For example, \texttt{hello|world!*}
            denotes the set $\{hello, world, world!, world!!, world!!!,
            \ldots\}$
        \end{itemize}

      \subsubsection{Classical algorithms}

        Given a deterministic finite automaton $\mathcal{A} = (Q, I, \Delta,
        F)$, it is possible to determine in time $O(|d|)$ whether the input
        document $d$ is part of the language recognised by $\mathcal{A}$. It
        only requires to simulate a run of the automaton while keeping in
        memory the only possible state $q_i$ reading $d_i$: initially $\{q_0\}
        = I$ and for each $1 \leq i \leq |d|$, $q_{i}$ is the only possible
        state such that $(q_{i-1}, d_i, q_i) \in \Delta$ if any, otherwise
        there is no run labeled with $d$ over $\mathcal{A}$. Finally, if the is
        such a run and it is valid ($q_n \in F$), $d \in L(\mathcal{A})$.

        If $\mathcal{A}$ is not deterministic, it is still possible to perform
        the same operation in time $O(|\mathcal{A}| |d|)$: it requires to
        simulate all possible runs by keeping the set $Q_i$ of all possible
        states of the execution of $A$ while reading $d_i$. If $\mathcal{A} =
        (Q, I, \delta, F)$:
        \begin{itemize}
          \item $Q_0 = I$
          \item $\forall 1 \leq i \leq |d|, Q_i = \{(q', d_i, q'') \in \delta,
            q' \in Q_{i-1}\}$
        \end{itemize}
        Finally, there is a valid run of $\mathcal{A}$ over $d$ if $Q_{|d|}
        \bigcap F \neq \emptyset$.

        \vspace{0.5cm}

        The next main issue is then to find an automata that recognises the
        language of an input regular expression. Thompson's algorithm
        introduces operation to recursively apply the operations of union,
        concatenation and closure to the automatons representing
        subexpressions~\cite{thompson1968programming}. This process is linear
        in the size of the expression but the resulting automata uses
        $\epsilon$-transitions that can be removed in time $O(n^2)$.

        Glushkov's algorithm in the other hand can also compute the same
        automaton with no $\epsilon$-transitions, by recursively computing the
        set of the first letters, last letters and factor two of the words in
        the regular language~\cite{glushkov1961abstract}\todo{check the
        source}. This process takes time $O(n^2)$.

      \subsubsection{Example}%
        \label{sec:example_simple}

        Let us consider the example of the regular expression $E =$
        \texttt{.*[\textasciicircum\_]+@[\textasciicircum\_]+.*} over the
        alphabet $\Sigma = \{a, b, \ldots, z, @, \texttt \_, \vdash, \dashv\}$.
        The central part (\texttt{[\textasciicircum\_]+@[\textasciicircum\_]+})
        of the expression matches an email-like pattern defined as a non-empty
        sequence of non-space characters (\texttt{[\textasciicircum\_]+})
        followed by \texttt{@}, followed by another non-empty sequence of
        non-space characters. The email-like pattern can be surrounded by any
        prefix or suffix.

        Figure~\ref{fig:automata_simple} is the graphical representation of a 4
        states automaton that recognises the same language as the above
        expression.

        For example, the word \texttt{send\_hello@world} is part of the
        language and an accepting run of the automaton of
        figure~\ref{fig:automata_simple} is $q_0 \underbrace{q_0 q_0 q_0
        q_0}_\texttt{send} q_0 \underbrace{q_1q_1q_1q_1}_\texttt{hello} q_2
        \underbrace{q_2 q_2 q_2 q_2 q_3}_\texttt{world}$.

        \begin{figure}[ht]%
            \label{fig:automata_simple}
            \centering
            \begin{tikzpicture}[automaton, auto]
              \node[state,initial]   (1)              {$q_0$};
              \node[state]           (3) [right=of 1] {$q_1$};
              \node[state]           (4) [right=of 3] {$q_2$};
              \node[state,accepting] (6) [right=of 4] {$q_3$};

              \path[->]
                (1) edge node {$\Sigma \setminus \texttt \_$} (3)
                    edge [loop above] node {$\Sigma$} ()
                (3) edge node {$@$} (4)
                    edge [loop above] node {$\Sigma \setminus \texttt \_$} ()
                (4) edge node {$\Sigma \setminus \texttt \_$} (6)
                    edge [loop above] node {$\Sigma \setminus \texttt \_$} ()
                (6) edge [loop above] node {$\Sigma$} ();
            \end{tikzpicture}
            \caption{An automata recognising the same regular language as
            \texttt{.*[\textasciicircum\_]+@[\textasciicircum\_]+.*}}
          \end{figure}

    \subsection{Variable set automata}

      \subsubsection{Document spanner}

        Let $\Sigma$ be a finite alphabet. A document $d = d_0 \dots d_{n-1}$
        is a word over $\Sigma$. A \textit{span} of $d$ is a pair $\Span{i, j}$
        with $0 \leq i \leq j \leq |d|$ which represents a substring of $d$
        starting at position $i$ and ending at position $j - 1$.

        Given a finite set $\mathcal{V}$ of variables, a result is defined as a
        \textit{mapping} from these variables to spans of the input document.
        Note that some variable may remain unassigned: formally, a mapping of
        $\mathcal{V}$ on $d$ is a function $\mu$ from some domain
        $\mathcal{V}_0 \subset \mathcal{V}$ to spans of $d$.

        We define a \textit{document spanner} to be a function assigning to
        every input document d a set of mappings, which denotes the set of
        results of the extraction task on the document d.

      \subsubsection{Sequential Variable Set Automata}

        Document spanners will here be represented using \textit{variable-set}
        automata (VAs). Transitions of a VA can either hold a letter
        of $\Sigma$ or a \textit{variable marker} $x{\vdash}$ (denoting the
        start of a span assigning to $x$), or ${\dashv}x$ (denoting the end of
        a span assigning to $x$), where $x \in \mathcal{V}$.

        Similarly to a classical automaton, given a finite alphabet $\Sigma$
        and a finite set of variables $\mathcal{V}$ a VA is defined as a tuple
        $A = (Q, q_0, F, \delta)$ where $\delta$ defines a set of
        \textit{transitions} of the form $(q, \sigma, q')$ where $\sigma \in
        \Sigma$ for \textit{letter transitions} or $\sigma \in \mathcal{V}$ for
        \textit{variable transitions}.

        A run $\sigma$ of $A$ over $d$ is defined as a sequence of
        configurations
          \[ (q_0, i_0) \xrightarrow{\sigma_1} (q_1, i_1)
          \xrightarrow{\sigma_2} \ldots \xrightarrow{\sigma_m} (q_m, i_m) \]
        where $i_0 = 0$, $i_m = |d|$ and for every $1 \leq j \leq m$:
          \begin{itemize}
            \item either $\sigma_j$ is a letter of $\Sigma$, we have $i_j =
              i_{j-1} + 1$, $d_{i_{j-1}} = \sigma_j$ and $(q_{j-1}, \sigma_j,
              q_j)$ is a letter transition of $A$;
            \item or $\sigma_j$ is a variable marker, we have $i_j = i_{j-1}$,
              and $(q_{j-1}, \sigma_j, q_j)$ is a variable transition of $A$. In
              this case we say that the variable marker $\sigma_j$ is read at
              position $i_j$.
          \end{itemize}

        A run is \textit{valid} if it is accepting ($q_m \in F$), every
        variable marker is read at most once, and whenever an open marker $x
        \vdash$ is read at a position $i$ then the corresponding close marker
        $\dashv x$ is read at a position $i'$ with $i \leq i'$.

        The algorithm will only take as input automata that can't be accepting
        but not valid. Such an automaton is called \textit{sequential}. Note
        that it is NP-complete to decide if a VA has a valid run over a
        document~\cite{freydenberger:LIPIcs:2017}. Also note that the problem
        of deciding if an automaton is sequential is in NL and that an
        automaton can be transformed into a sequential automaton with an
        exponential blowup.

        From each valid run a mapping is defined where each variable $x \in V$
        is mapped to the span $\Span{i, i'}$ such that $x \dashv$ is read at
        position $i$ and $\vdash x$ is read at position $i'$; if these markers
        are not read then $x$ is not assigned by the mapping (i.e., it is not
        in the domain $\mathcal{V}_0$). The document spanner of the VA $A$ is
        then the function that assigns to every document $d$ the set of
        mappings defined by the valid runs of $A$ on $d$: note that the same
        mapping can be defined by multiple different runs.

        \todo{This should be more visible}
        The task of the enumeration algorithm defined in~\cite{ICDT19} is the
        following: given a VA $A$ and a document $d$, enumerate without
        duplicates the mappings that are assigned to $d$ by the document
        spanner of $A$.

    \subsection{Regex Formulas}
      \todo[inline]{Somehow quote Liat}

      Given a finite alphabet $\Sigma$ and a finite set of variables
      $\mathcal{V}$, a \textit{ref-word} is a word over the extended alphabet
      $\Sigma \cup \Gamma_\mathcal{V}$ where $\Gamma_\mathcal{V} = \{x{\vdash},
      x \in \mathcal{V}\} \cup \{{\dashv}x, x \in \mathcal{V}\}$. A ref-word $r
      \in \Sigma \cup \Gamma_\mathcal{V}$ is \textit{valid} if every variable
      of $\mathcal{V}$ is opened and closed exactly once (each marker of
      $\Gamma_\mathcal{V}$ appears exactly once in $r$).


      The set of \textit{regex formulas} is the smallest set containing regular
      expressions, closed by the same rules as regular expressions and such
      that for any regex formula $E$ and variable $x \in \mathcal{V}$, $x\{E\}$
      is a regex formula.

      A regex formula $E$ denotes words over the extended alphabet $\Sigma
      \cup \Gamma_\mathcal{V}$ like so:
        \begin{itemize}
          \item if $E = x\{E'\}$ for some regex formula $E'$, then $E$ denotes
            the set of words of the form $x{\vdash} u {\dashv}x$ where $u$ is
            denoted by $E'$
          \item the rules of closure, union and concatenation apply in the same
            way as they do for regular expressions
        \end{itemize}

      We say that a regex-formula $r$ is \textit{functional} if every ref-word
      denoted by $r$ is valid. We will only consider functional regex formulas.

      Given a word $d \in \Sigma^*$ and a regex formula $E$, $\Ref(E, d)$ is the
      set of ref-words $r$ denoted by $E$ such that $r \cap \Sigma = d$ (where
      $r \cap \Sigma = r_{\sigma_1} r_{\sigma_2}, \ldots, r_{\sigma_m}$ such
      that $\sigma$ is strictly increasing, $m$ is maximal and $\forall 1 \leq
      i \leq m, r_{\sigma_i} \in \Sigma$).

      If $E$ is functional, for all $d \in \Sigma^*$, $r \in \Ref(E, d)$, we can
      extract for any variable $x \in \mathcal{V}$ a span of $d$: $\mu^r (x) =
      \Span{i, j}$ such that there is exactly $i$ letters of $\Sigma$ before
      $x{\vdash}$ and $j$ letters of $\Sigma$ after ${\dashv}x$ in $r$.

      A functional regex formula $E$ defines a document spanner over words of
      $\Sigma^*$: $\llbracket E \rrbracket (d) = \{\mu^r, r \in \Ref(E, d)\}$.

      \todo[inline]{Maybe had some details. How to adapt Glushkov, reference
      that functional is decidable...}

    \subsection{Example}
      Let us modify the example of Section~\ref{sec:example_simple} to extract
      the position of an email-like pattern into a variable:
      \texttt{.*x\{[\textasciicircum\_]+@[\textasciicircum\_]+\}.*}.

      Figure~\ref{fig:automata} represents an automaton that induces the same
      document spanner as this regex.

      For example, over the word \texttt{send\_hello@world}, the substring
      \texttt{hello@world} is assigned to $x$ in a valid run over $r =$
      \texttt{send\_$x{\vdash}$hello@world${\dashv}x$} since $\mu^r(x) =
      \Span{5, 16}$. Such a valid run over $r$ is $q_0 \underbrace{q_1 q_1 q_1
      q_1 q_1}_\texttt{send\_} \underbrace{q_2}_{{\vdash}x} \underbrace{q_3 q_3
      q_3 q_3 q_4 q_5 q_5 q_5 q_5 q_5}_\texttt{hello@world}
      \underbrace{q_6}_{{\dashv}x}$.

      \begin{figure}[ht]%
        \label{fig:automata}
        \centering
        \begin{tikzpicture}[automaton, auto]
          \node[state,initial]   (0)              {$q_0$};
          \node[state]           (1) [right=of 0] {$q_1$};
          \node[state]           (2) [right=of 1] {$q_2$};
          \node[state]           (3) [right=of 2] {$q_3$};
          \node[state]           (4) [right=of 3] {$q_4$};
          \node[state]           (5) [right=of 4] {$q_5$};
          \node[state,accepting] (6) [right=of 5] {$q_6$};
          \node[state,accepting] (7) [right=of 6] {$q_7$};

          \path[->]
            (0) edge node {$\Sigma$} (1)
                edge [bend right] node [below] {$\vdash x$} (2)
            (1) edge node {$\vdash x$} (2)
                edge [loop above] node {$\Sigma$} ()
            (2) edge node {$\Sigma \setminus \texttt \_$} (3)
            (3) edge node {$@$} (4)
                edge [loop above] node {$\Sigma \setminus \texttt \_$} ()
            (4) edge node {$\Sigma \setminus \texttt \_$} (5)
            (5) edge node {$\dashv x$} (6)
                edge [loop above] node {$\Sigma \setminus \texttt \_$} ()
            (6) edge node {$\Sigma$} (7)
            (7) edge [loop above] node {$\Sigma$} ();
        \end{tikzpicture}
        \caption{%
          An automata recognising the same regular language as
          \texttt{.*x\{[\textasciicircum\_]+@[\textasciicircum\_]+\}.*}
        }%
        \label{ex:intro-1}
      \end{figure}


    \section{Related work}

      \todo[inline]{%
        Florenzano \& al \\
        Anything else?
      }


  \section{Outline of the enumeration algorithm}
      \includepdf{figures/example_dag.pdf}


  \section{Implementation}

    % Some implementation details, out of a subsection

    \subsection{Technical details}

      \todo{%
        Parler de Glushkov et du parsing dans l'overview de l'algo, pas
        vraiment ici
      }

      A first draft of the implementation of the algorithm was implemented
      using Python 3, this programming language is known to be slow but its
      flexibility allowed to get a working implementation after about a week of
      work. The expression are parsed using a LALR parser for a custom grammar,
      and are converted to an automata using Glushkov's algorithm.

      I later built an implementation using Rust in order to be able to compare
      performances of the algorithm with existing tools without suffering of
      the overhead of Python. The regex crate of Rust allows to access the
      AST of parsed regexps, but I still needed to compile the into automaton
      using Glushkov's algorithm in order to handle variables.

      These tools work similarly to other pattern matching tools like grep and
      use the same regex syntax. Variables are defined out of named groups, and
      instead of outputting a single match with a single assignation to groups,
      it outputs the list of all possible assignations of groups of the
      expressions.

      \todo{Introduire le naïf quelque-part par ici?}.

    \subsection{Limitations}

      \todo[inline]{trucs pas time efficient (hashtables, matrices?)}

    \subsection{Cleaning unreachable states}


  \section{Performance of the algorithm}

    \subsection{Limitations of existing tools}

      Excepted for the naive algorithms and the work of Florenzano \&
      al.~\todo{reference}, it is difficult to fairly compare to already
      existing tools. Some of these tools allow to output a list of overlapping
      matches, however this will at most output one match for each starting
      position in the output document. Regex actually have a greedy semantic
      for closures in the context of these tools, it will as a default match
      the largest possible string for each closure and can be turned to a lazy
      semantic where it only matches the smallest possible string. For
      example over the text \texttt{abcde} by using gnu grep:
        \begin{itemize}
          \item the regexp \texttt{...*} will output \texttt{abcde},
            \texttt{bcde}, \texttt{cde}, \texttt{de}
          \item the regexp \texttt{...*?} (where \texttt{*?} is the lazy
            version of \texttt{*}) will output \texttt{ab}, \texttt{bc},
            \texttt{cd} and \texttt{de}
        \end{itemize}
      However, the output to the enumeration problem should contain all
      substrings of size at least 2, thus these two kinds of greedy semantics
      don't need to be treated separatly.

    \subsection{Results}


  \pagebreak
  \bibliography{bibliography}
  \bibliographystyle{ieeetr}

\end{document}
